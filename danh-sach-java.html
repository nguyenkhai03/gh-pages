<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Danh sách Java - Profile</title><meta name="description" content="Java Collection Framework chứa các giao diện và lớp rất hữu ích triển khai chúng để làm việc với các cấu trúc dữ&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html"><link rel="alternate" type="application/atom+xml" href="https://nguyenkhai03.github.io/gh-pages/feed.xml"><link rel="alternate" type="application/json" href="https://nguyenkhai03.github.io/gh-pages/feed.json"><meta property="og:title" content="Danh sách Java"><meta property="og:image" content="https://nguyenkhai03.github.io/gh-pages/media/posts/7/list-java.jpg"><meta property="og:image:width" content="900"><meta property="og:image:height" content="480"><meta property="og:site_name" content="Profile"><meta property="og:description" content="Java Collection Framework chứa các giao diện và lớp rất hữu ích triển khai chúng để làm việc với các cấu trúc dữ&hellip;"><meta property="og:url" content="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/fontawesome-all.min.css?v=85514f933f9e0b82460af63f1a403fa5"><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/style.css?v=a43d11e6c8e1828dd0b983b73b3cdb13"><noscript><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/noscript.css?v=efa867a99f5064d6729e4dc2008ad50b"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html"},"headline":"Danh sách Java","datePublished":"2024-12-31T20:57+07:00","dateModified":"2024-12-31T23:31+07:00","image":{"@type":"ImageObject","url":"https://nguyenkhai03.github.io/gh-pages/media/posts/7/list-java.jpg","height":480,"width":900},"description":"Java Collection Framework chứa các giao diện và lớp rất hữu ích triển khai chúng để làm việc với các cấu trúc dữ&hellip;","author":{"@type":"Person","name":"Nguyễn Đăng Khải","url":"https://nguyenkhai03.github.io/gh-pages/authors/nguyen-dang-khai/"},"publisher":{"@type":"Organization","name":"Nguyễn Đăng Khải"}}</script><style>#wrapper > .bg {
               background-image: url(https://nguyenkhai03.github.io/gh-pages/assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(https://nguyenkhai03.github.io/gh-pages/media/website/photo-1506126613408-eca07ce68773.avif);
           }</style><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="is-preload post-template"><div id="wrapper"><header id="header"><a class="logo" href="https://nguyenkhai03.github.io/gh-pages/">Profile</a></header><nav id="nav"><ul class="links"><li><a href="https://nguyenkhai03.github.io/gh-pages/" target="_self">HOME</a></li><li><a href="https://nguyenkhai03.github.io/gh-pages/tags/blog/" target="_self">BLOG</a></li><li><a href="https://nguyenkhai03.github.io/gh-pages/profile-ca-nhan.html" target="_self">PROFILE</a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2024-12-31T20:57" class="date">December 31, 2024</time><h1>Danh sách Java</h1><p class="post__inner"></p></header><figure class="image main"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/7/list-java.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="480" width="900" alt=""></figure><div class="post__inner post__entry"><p>Java Collection Framework chứa các giao diện và lớp rất hữu ích triển khai chúng để làm việc với các cấu trúc dữ liệu. Có thể nói đây là một trong những JDK framework quan trọng nhất. Giao diện Danh sách rất phổ biến. bởi vì không có tất cả các loại danh sách trong lập trình thì nó là điều không thể thiếu. Trong bài viết này, chúng tôi sẽ đề cập đến giao diện này, các phương thức và triển khai Danh sách Java.</p><h2>Giao diện danh sách Java</h2><p>Điều quan trọng nhất về một danh sách là nó là một tập hợp <span class="text-bold"><em>có thứ tự</em></span> . Bạn cũng có thể gọi nó là một chuỗi. Trong Java, danh sách là đồng nhất, nghĩa là các phần tử của danh sách có cùng kiểu dữ liệu. Giao diện Danh sách Java kế thừa từ Bộ sưu tập, nó kế thừa tất cả các hoạt động của nó. Ngoài chúng, các thao tác sau cũng có thể thực hiện được trong Danh sách:</p><ul><li>Truy cập vị trí. Mỗi phần tử có một chỉ mục và có thể được thao tác dựa trên vị trí của chúng. trong danh sách. Tức là bạn có thể thêm, loại trừ và sửa đổi các phần tử.</li><li>Tìm kiếm. Bạn có thể tìm một phần tử trong danh sách theo nội dung của nó và trả về chỉ mục của nó.</li><li>Lặp lại. Tính chất tuần tự của List cho phép sử dụng phương thức lặp (listIterator).</li><li>Phạm vi xem. Phương thức danh sách con thực hiện các thao tác phạm vi tùy ý trên danh sách.</li></ul><h2>Các phương thức danh sách Java</h2><p>Các hoạt động trên được hiển thị trong các phương thức của giao diện Danh sách Java. Đây là một số trong số họ:</p><div class="table-container"><div class="table-container"><table><tbody><tr><th>Phương pháp</th><th>Sự miêu tả</th></tr><tr><td><span class="code">thêm (phần tử E)</span></td><td>Phương thức này thêm phần tử <span class="text-bold"><em>phần tử</em></span> vào cuối danh sách này.</td></tr><tr><td><span class="code">thêm (chỉ số int, phần tử)</span></td><td>Phương thức thêm một phần tử tại một chỉ mục cụ thể trong danh sách. Nếu một tham số cần thiết được truyền vào, nó sẽ thêm phần tử vào cuối danh sách.</td></tr><tr><td><span class="code">addAll(int index, Bộ sưu tập bộ sưu tập)</span></td><td>Thêm tất cả các phần tử trong bộ sưu tập đã cho vào danh sách. Nếu một tham số duy nhất được truyền vào, nó sẽ thêm tất cả các phần tử của tập hợp đã cho vào cuối danh sách.</td></tr><tr><td><span class="code">kích cỡ()</span></td><td>Trả về kích thước của danh sách (số lượng phần tử trong danh sách).</td></tr><tr><td><span class="code">lấy (chỉ số int)</span></td><td>Trả về phần tử tại chỉ mục đã chỉ định.</td></tr><tr><td><span class="code">thiết lập (chỉ số int, phần tử)</span></td><td>Thay thế các phần tử tại một chỉ mục nhất định bằng phần tử mới và trả về phần tử đã được thay thế bằng phần tử mới.</td></tr><tr><td><span class="code">xóa (chỉ số int)</span></td><td>Xóa một phần tử khỏi chỉ mục đã chỉ định.</td></tr><tr><td><span class="code">xóa (phần tử)</span></td><td>Loại bỏ sự xuất hiện đầu tiên của phần tử đã cho trong danh sách.</td></tr><tr><td><span class="code">thông thoáng()</span></td><td>Xóa tất cả các phần tử khỏi danh sách.</td></tr><tr><td><span class="code">indexOf(phần tử)</span></td><td>Trả về lần xuất hiện đầu tiên của phần tử đã cho. Nếu phần tử không có trong danh sách, trả về <em>-1</em> .</td></tr><tr><td><span class="code">lastIndexOf(phần tử)</span></td><td>Trả về lần xuất hiện cuối cùng của phần tử đã cho. Nếu phần tử không có trong danh sách, trả về <em>-1</em> .</td></tr><tr><td><span class="code">bằng (phần tử)</span></td><td>So sánh sự bằng nhau của phần tử đã cho với các phần tử của danh sách.</td></tr><tr><td><span class="code">Mã Băm()</span></td><td>Trả về giá trị mã băm của danh sách đã cho.</td></tr><tr><td><span class="code">isEmpty()</span></td><td>Kiểm tra xem danh sách có trống không. Trả về true nếu danh sách trống.</td></tr><tr><td><span class="code">chứa (phần tử)</span></td><td>Kiểm tra xem danh sách có chứa <span class="text-bold"><em>phần tử</em></span> hay không . Trả về true nếu danh sách chứa phần tử.</td></tr><tr><td><span class="code">chứaAll(Bộ sưu tập)</span></td><td>Kiểm tra xem danh sách có chứa tất cả tập hợp các phần tử hay không.</td></tr><tr><td><span class="code">sắp xếp (So sánh comp)</span></td><td>Sắp xếp các phần tử của danh sách trên cơ sở bộ so sánh đã cho.</td></tr><tr><td><span class="code">danh sách con (int from Index, int to Index)</span></td><td>Trả về dạng xem của phần danh sách này giữa fromIndex, bao gồm và toIndex, độc quyền đã chỉ định.</td></tr></tbody></table></div></div><h2>Danh sách thực hiện</h2><p>Bởi vì Danh sách là một giao diện, các chương trình cần tạo ra một triển khai cụ thể cho nó. Bạn có thể chọn giữa các triển khai Danh sách sau trong API Bộ sưu tập Java:</p><ul><li><span class="code">java.util.ArrayList</span></li><li><span class="code">java.util.LinkedList</span></li><li><span class="code">java.util.Vector</span></li><li><span class="code">java.util.Stack</span></li></ul><p>Việc triển khai phổ biến nhất của giao diện Danh sách được gọi là ArrayList. Ít thường xuyên hơn, nhưng bạn vẫn có thể thấy việc sử dụng LinkedList trong các tác vụ thực tế, nhưng Vector và Stack đã trở nên lỗi thời về mặt đạo đức trong một thời gian dài, vì vậy rất có thể bạn sẽ chỉ tìm thấy chúng trong các dự án có mã kế thừa cổ xưa.</p><h2>Khai báo giao diện danh sách</h2><p>Bạn có thể khai báo một List trong chương trình Java theo một trong các cách sau:</p><pre class="line-numbers language-java" tabindex="0"><code>List&lt;String&gt; myList = new ArrayList();
List myList1 = new ArrayList();
List myList3 = new ArrayList&lt;String&gt;();
ArrayList arrayList = new ArrayList();</code></pre><p>Tốt nhất là khai báo một danh sách mới thông qua một giao diện. Tương tự, bạn có thể khai báo các triển khai khác của Danh sách. Con đường ngắn nhất:</p><pre class="line-numbers language-java" tabindex="0"><code>Vector myVector = new Vector;
LinkedList linkedList = new LinkedList();
Stack stack = new Stack();</code></pre><p>Với cách khai báo như vậy, kiểu dữ liệu của các phần tử trong danh sách đó được xác định trong quá trình khởi tạo danh sách, tức là khi các phần tử được thêm vào đó.</p><pre class="line-numbers language-java" tabindex="0"><code>List myList = new ArrayList&lt;String&gt;();
Vector myVector = new Vector();
LinkedList linkedList = new LinkedList();
Stack stack = new Stack();
stack.add("Paul");
linkedList.add(1);
myVector.add(1.2f);
myList.add('a');</code></pre><p>Bây giờ chỉ có thể thêm các chuỗi vào ngăn xếp của chúng tôi, các số nguyên vào <span class="code">LinkedList</span> , float vào <span class="code">myVector</span> và <span class="code">myList</span> là một danh sách các ký tự.</p><h2>ArrayList hoạt động như thế nào</h2><p>Nếu bạn đã quen thuộc với các mảng thông thường, thì bạn cũng đã phần nào quen thuộc với ArrayList. Thực tế, ArrayList là một mảng động, và bên trong nó là một mảng thông thường. Mảng này hoạt động như một kho lưu trữ dữ liệu. ArrayList chỉ lưu trữ các loại tham chiếu, bất kỳ đối tượng nào, bao gồm các lớp bên thứ ba, chuỗi, luồng đầu ra và các bộ sưu tập khác. Các lớp bao bọc được sử dụng để lưu trữ các kiểu dữ liệu nguyên thủy trong ArrayList. Khi tạo danh sách, chúng tôi có thể đặt kích thước của nó ngay lập tức, nhưng trong hầu hết các trường hợp, chúng tôi không làm như vậy. Theo mặc định, kích thước ArrayList = 10. Việc thêm phần tử mới vào ArrayList trông như thế nào? Trước hết, một cuộc kiểm tra được bắt đầu để xem liệu có đủ khoảng trống trong mảng bên trong hay không và liệu một phần tử nữa có phù hợp hay không. Nếu có khoảng trống, phần tử mới sẽ được thêm vào cuối danh sách, nghĩa là vào ô theo sau phần tử cuối cùng. Chỉ mục của nó sẽ là arraylist.size(). Nếu chúng ta vừa tạo danh sách của mình và nó trống, điều này có nghĩa là arrayList.size() = 0. Theo đó, một phần tử mới sẽ được thêm vào ô có chỉ số 0. Nếu không đủ chỗ, một phần tử mới sẽ được thêm vào. mảng được tạo bên trong ArrayList với kích thước (kích thước của OldArray * 1.5) + 1. Theo nguyên tắc tương tự, việc chèn xảy ra ở giữa danh sách, nhưng đồng thời, tất cả các phần tử theo sau phần tử được chèn đều chuyển sang bên phải. Vì vậy, nếu chúng ta có 5 phần tử trong mảng và chúng ta cần chèn một phần tử vào ô số 2 (nghĩa là ô thứ ba), thì các phần tử mảng 0 và 1 vẫn giữ nguyên vị trí, một phần tử mới xuất hiện trong ô 2 và tiền thân của nó đi đến ô thứ ba, v.v. một phần tử mới sẽ được thêm vào ô có chỉ số 0. Nếu không có đủ dung lượng, một mảng mới sẽ được tạo bên trong ArrayList với kích thước (kích thước của OldArray * 1.5) + 1. Tương tự nguyên tắc, một phép chèn xảy ra ở giữa danh sách, nhưng đồng thời, tất cả các phần tử theo sau phần tử được chèn đều được dịch sang phải. Vì vậy, nếu chúng ta có 5 phần tử trong mảng và chúng ta cần chèn một phần tử vào ô số 2 (nghĩa là ô thứ ba), thì các phần tử mảng 0 và 1 vẫn giữ nguyên vị trí, một phần tử mới xuất hiện trong ô 2 và tiền thân của nó đi đến ô thứ ba, v.v. một phần tử mới sẽ được thêm vào ô có chỉ số 0. Nếu không có đủ dung lượng, một mảng mới sẽ được tạo bên trong ArrayList với kích thước (kích thước của OldArray * 1.5) + 1. Tương tự nguyên tắc, một phép chèn xảy ra ở giữa danh sách, nhưng đồng thời, tất cả các phần tử theo sau phần tử được chèn đều được dịch sang phải. Vì vậy, nếu chúng ta có 5 phần tử trong mảng và chúng ta cần chèn một phần tử vào ô số 2 (nghĩa là ô thứ ba), thì các phần tử mảng 0 và 1 vẫn giữ nguyên vị trí, một phần tử mới xuất hiện trong ô 2 và tiền thân của nó đi đến ô thứ ba, v.v. một phép chèn xảy ra ở giữa danh sách, nhưng đồng thời, tất cả các phần tử theo sau phần tử được chèn đều được dịch sang phải. Vì vậy, nếu chúng ta có 5 phần tử trong mảng và chúng ta cần chèn một phần tử vào ô số 2 (nghĩa là ô thứ ba), thì các phần tử mảng 0 và 1 vẫn giữ nguyên vị trí, một phần tử mới xuất hiện trong ô 2 và tiền thân của nó đi đến ô thứ ba, v.v. một phép chèn xảy ra ở giữa danh sách, nhưng đồng thời, tất cả các phần tử theo sau phần tử được chèn đều được dịch sang phải. Vì vậy, nếu chúng ta có 5 phần tử trong mảng và chúng ta cần chèn một phần tử vào ô số 2 (nghĩa là ô thứ ba), thì các phần tử mảng 0 và 1 vẫn giữ nguyên vị trí, một phần tử mới xuất hiện trong ô 2 và tiền thân của nó đi đến ô thứ ba, v.v.</p><h2>Ví dụ về danh sách Java (hiện thực hóa danh sách mảng)</h2><pre class="line-numbers language-java" tabindex="0"><code>import java.util.*;

public class ArrayListExample2 {
   public static void main(String[] args) {
       List&lt;String&gt; myFriendsList = new ArrayList();
       
       System.out.println( "the size of myList before init = " + myFriendsList.size());
       myFriendsList.add("Alex");
       myFriendsList.add("Tanya");
       myFriendsList.add("Veloxy");
       myFriendsList.add("Alex");
       myFriendsList.add("Andrew");
       System.out.println(myFriendsList);
       System.out.println( "the size of myList after init = " + myFriendsList.size());

       myFriendsList.add("Ihor");
       System.out.println(myFriendsList);
       System.out.println("the size of my list = " +  myFriendsList.size());


       
       System.out.println(myFriendsList.indexOf("Alex"));
       

       myFriendsList.remove(3);
       System.out.println(myFriendsList.get(3));
       System.out.println("after removing one of Alex's there is only one Alex: " + myFriendsList);
       System.out.println(myFriendsList.get(1));



       myFriendsList.clear();
       System.out.println("the size of the vector after clear method = " +  myFriendsList.size());

   }
}</code></pre><p>Đây là đầu ra của chương trình này:</p><div class="terminal">kích thước của myList trước init = 0 [Alex, Tanya, Veloxy, Alex, Andrew] kích thước của myList sau init = 5 [Alex, Tanya, Veloxy, Alex, Andrew, Ihor] kích thước danh sách của tôi = 6 0 Andrew sau khi loại bỏ một trong những Alex thì chỉ còn một Alex: [Alex, Tanya, Veloxy, Andrew, Ihor] Tanya kích thước của vectơ sau phương thức xóa = 0 Quá trình kết thúc với mã thoát 0</div><h2>LinkedList hoạt động như thế nào</h2><p>Trong LinkedList, các phần tử thực sự là các liên kết trong cùng một chuỗi. Mỗi phần tử, ngoài dữ liệu mà nó lưu trữ, có một liên kết đến phần tử trước đó và phần tử tiếp theo. Các liên kết này cho phép bạn điều hướng từ phần tử này sang phần tử khác. Trình vòng lặp hỗ trợ truyền tải theo cả hai hướng. Triển khai các phương thức lấy, xóa và chèn vào đầu, giữa và cuối danh sách. Cho phép bạn thêm bất kỳ yếu tố nào kể cả null. LinkedList triển khai hai giao diện — không chỉ Danh sách mà còn cả Deque. Điều này cung cấp khả năng tạo hàng đợi hai chiều từ bất kỳ phần tử nào, thậm chí là null. Mỗi đối tượng được đặt trong danh sách liên kết là một nút (node). Mỗi nút chứa một phần tử, một liên kết đến nút trước và nút tiếp theo. Trên thực tế, danh sách được liên kết bao gồm một chuỗi các nút, mỗi nút được thiết kế để lưu trữ một đối tượng thuộc loại được xác định khi nó được tạo.</p><h2>Mã ví dụ</h2><pre class="line-numbers language-java" tabindex="0"><code>import java.util.*;
public class LinkedListTest {

       public static void main(String args[]){

           List myLinkedList= new LinkedList&lt;Integer&gt;();
           myLinkedList.add(1);
           myLinkedList.add(2);
           myLinkedList.add(4);
           System.out.println("three added elements: " + myLinkedList);
           myLinkedList.add(5);
           myLinkedList.remove(1);
           System.out.println(myLinkedList);
           myLinkedList.size(); 

           
           myLinkedList.add(2,7);
           System.out.println(myLinkedList);
                }
       }</code></pre><p>Đầu ra ở đây:</p><div class="terminal">ba yếu tố được thêm vào: [1, 2, 4] [1, 4, 5] [1, 4, 7, 5]</div><h2>Ví dụ mã véc tơ</h2><p>Vector cũng là một mảng động và rất giống với ArrayList, nhưng được đồng bộ hóa và có một số phương thức kế thừa mà khung bộ sưu tập không có. Đây là một ví dụ đơn giản về việc sử dụng lớp này.</p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Vector;

public class VectorExample1 {

   public static void main(String[] args) {
       Vector vector = new Vector();
       System.out.println("the size of the empty vector = " +  vector.size());
       vector.add("Alex");
       vector.add("Tanya");
       vector.add("Andrew");
       System.out.println(vector);
       vector.add("Alex");
       vector.add("Ihor");
       System.out.println(vector);
       System.out.println("the size of the vector = " +  vector.size());
       System.out.println("the first element of the vector = " + vector.firstElement());

       
       System.out.println(vector.indexOf("Andrew"));
       
       System.out.println(vector.indexOf("Alex", 1));
       System.out.println(vector);
       vector.clear();
       System.out.println("the size of the vector after clear method = " +  vector.size());

   }
}</code></pre><p>Đầu ra là:</p><div class="terminal">kích thước của vectơ trống = 0 [Alex, Tanya, Andrew] [Alex, Tanya, Andrew, Alex, Ihor] kích thước của vectơ = 5 phần tử đầu tiên của vectơ = Alex 2 3 [Alex, Tanya, Andrew, Alex, Ihor] kích thước của vectơ sau phương thức xóa = 0 Quá trình kết thúc với mã thoát 0</div><h2>Mã lớp Java Stack Ví dụ</h2><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Stack;

public class StackTest {
   public static void main(String[] args) {
       Stack stack = new Stack();
       System.out.println(stack.isEmpty());
       stack.add("Paul");
       stack.add("Johnny");
       stack.add("Alex");
       System.out.println(stack.isEmpty());
       stack.push("Andrew");
       System.out.println(stack);
       stack.pop();
       System.out.println(stack);
   }
}</code></pre><p>Stack không chỉ có các phương thức <span class="code">add()</span> và <span class="code">remove()</span> mà còn có cả push và pop, chúng là cổ điển cho cấu trúc dữ liệu như vậy. Ngăn xếp tuân theo quy tắc “vào trước, ra sau” — đây là một cách chống hàng đợi. Do đó, thao tác pop bật phần tử được đặt lần cuối trên ngăn xếp. Đây là đầu ra của ví dụ của chúng tôi:</p><div class="terminal">đúng sai [Paul, Johnny, Alex, Andrew] [Paul, Johnny, Alex]</div></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on December 31, 2024</p><div class="post__share-tag-container"><div class="post__tag"><h3>Tagged in:</h3><ul><li><a href="https://nguyenkhai03.github.io/gh-pages/tags/blog/">BLOG</a></li></ul></div><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"></div></div></div><div class="post__bio"><img src="https://nguyenkhai03.github.io/gh-pages/media/website/351272991_979314233203495_2887816723783302460_n.jpg" loading="lazy" height="206" width="218" alt="Nguyễn Đăng Khải"><div><h3><a href="https://nguyenkhai03.github.io/gh-pages/authors/nguyen-dang-khai/" class="invert" rel="author">Nguyễn Đăng Khải</a></h3></div></div></footer></article><div><strong>You should also read:</strong></div><div class="posts"><article><header><time datetime="2024-12-31T23:59" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html">Các Công Cụ Tối Ưu Hóa JavaScript</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/12/1706322865-yRkGgMr.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="500" width="800" alt=""></a><p>Nếu bạn đang băn khoăn tìm kiếm cho mình một thư viện JavaScript hay ho thì bạn đã ghé đúng nơi rồi. Ở&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:59" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html">Vòng lặp Java While</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/9/hqdefault.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="360" width="480" alt="Vòng lặp Java While"></a><p>Vòng lặp while được tìm thấy trong hầu hết mọi ngôn ngữ lập trình và Java cũng không ngoại lệ. Vòng lặp While&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:56" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html">Lớp Java.util.Random</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/6/Random-trong-java-la-gi-3.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="383" width="679" alt=""></a><p>Lớp java.util.Random trong Java là gì? Lớp java.util.Random được sử dụng để tạo các số giả ngẫu nhiên. Các phương thức do lớp&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:56" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/ngan-xep-java.html">Ngăn xếp Java</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/ngan-xep-java.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/5/cropped-cropped-icon-new-1.png" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-xs.png 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-sm.png 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-md.png 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-lg.png 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-xl.png 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="512" width="512" alt=""></a><p>Ngăn xếp trong Java thường có nghĩa là lớp từ Bộ sưu tập Khung triển khai giao diện Danh sách. Nó hoạt động&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/ngan-xep-java.html" class="button">Full Story</a></li></ul></article></div></main><footer id="copyright"><ul><li>© Massively</li><li>Design: <a href="https://html5up.net" target="_blank" rel="nofollow noopener">HTML5 UP</a></li><li>Powered by Publii</li></ul></footer></div><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.min.js?v=c9771cc3e90e18f5336eedbd0fffb2cf"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/main.min.js?v=56233c354bd814758be8bff42f7e13a5"></script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>