<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Ngăn xếp Java - Profile</title><meta name="description" content="Ngăn xếp trong Java thường có nghĩa là lớp từ Bộ sưu tập Khung triển khai giao diện Danh sách. Nó hoạt động&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nguyenkhai03.github.io/gh-pages/ngan-xep-java.html"><link rel="alternate" type="application/atom+xml" href="https://nguyenkhai03.github.io/gh-pages/feed.xml"><link rel="alternate" type="application/json" href="https://nguyenkhai03.github.io/gh-pages/feed.json"><meta property="og:title" content="Ngăn xếp Java"><meta property="og:image" content="https://nguyenkhai03.github.io/gh-pages/media/posts/5/cropped-cropped-icon-new-1.png"><meta property="og:image:width" content="512"><meta property="og:image:height" content="512"><meta property="og:site_name" content="Profile"><meta property="og:description" content="Ngăn xếp trong Java thường có nghĩa là lớp từ Bộ sưu tập Khung triển khai giao diện Danh sách. Nó hoạt động&hellip;"><meta property="og:url" content="https://nguyenkhai03.github.io/gh-pages/ngan-xep-java.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/fontawesome-all.min.css?v=85514f933f9e0b82460af63f1a403fa5"><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/style.css?v=a43d11e6c8e1828dd0b983b73b3cdb13"><noscript><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/noscript.css?v=efa867a99f5064d6729e4dc2008ad50b"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nguyenkhai03.github.io/gh-pages/ngan-xep-java.html"},"headline":"Ngăn xếp Java","datePublished":"2024-12-31T20:56+07:00","dateModified":"2024-12-31T23:31+07:00","image":{"@type":"ImageObject","url":"https://nguyenkhai03.github.io/gh-pages/media/posts/5/cropped-cropped-icon-new-1.png","height":512,"width":512},"description":"Ngăn xếp trong Java thường có nghĩa là lớp từ Bộ sưu tập Khung triển khai giao diện Danh sách. Nó hoạt động&hellip;","author":{"@type":"Person","name":"Nguyễn Đăng Khải","url":"https://nguyenkhai03.github.io/gh-pages/authors/nguyen-dang-khai/"},"publisher":{"@type":"Organization","name":"Nguyễn Đăng Khải"}}</script><style>#wrapper > .bg {
               background-image: url(https://nguyenkhai03.github.io/gh-pages/assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(https://nguyenkhai03.github.io/gh-pages/media/website/photo-1506126613408-eca07ce68773.avif);
           }</style><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="is-preload post-template"><div id="wrapper"><header id="header"><a class="logo" href="https://nguyenkhai03.github.io/gh-pages/">Profile</a></header><nav id="nav"><ul class="links"><li><a href="https://nguyenkhai03.github.io/gh-pages/" target="_self">HOME</a></li><li><a href="https://nguyenkhai03.github.io/gh-pages/tags/blog/" target="_self">BLOG</a></li><li><a href="https://nguyenkhai03.github.io/gh-pages/profile-ca-nhan.html" target="_self">PROFILE</a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2024-12-31T20:56" class="date">December 31, 2024</time><h1>Ngăn xếp Java</h1><p class="post__inner"></p></header><figure class="image main"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/5/cropped-cropped-icon-new-1.png" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-xs.png 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-sm.png 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-md.png 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-lg.png 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/5/responsive/cropped-cropped-icon-new-1-xl.png 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="512" width="512" alt=""></figure><div class="post__inner post__entry"><p>Ngăn xếp trong Java thường có nghĩa là lớp từ Bộ sưu tập Khung triển khai giao diện Danh sách. Nó hoạt động theo nguyên tắc cấu trúc dữ liệu Stack, được sử dụng để tổ chức một trong các loại bộ nhớ. Ngoài ra, nó có thể là một phần của bộ nhớ để lưu giữ dữ liệu, Trong bài viết này, trước hết chúng ta sẽ chú ý đến lớp <span class="code">Stack</span> , xem xét các phương thức của nó và đưa ra các ví dụ. Nhưng chúng ta cũng sẽ nói về cấu trúc dữ liệu như <span class="code">Stack</span> và nó được sử dụng để làm gì.</p><h2>Cấu trúc dữ liệu ngăn xếp là gì</h2><p>Trước hết, chúng ta hãy xem nhanh cấu trúc dữ liệu ngăn xếp là gì. Đó là cấu trúc dữ liệu tuyến tính dựa trên nguyên tắc Nhập trước xuất trước (LIFO). Đó là loại chống xếp hàng. Hãy tưởng tượng một cỗ bài hoặc một chồng sách trong hộp. Cuốn sách mà bạn đặt vào ngăn xếp đầu tiên nằm ở dưới cùng và cuốn sách đầu tiên chúng ta sẽ lấy ra khỏi hộp là cuốn sách ở trên cùng - tức là cuốn sách được cho vào hộp cuối cùng. Dưới đây là một hình ảnh gif để chứng minh nguyên tắc này. <img src="https://cdn.codegym.cc/images/article/f8e725f0-50c1-4854-a2f0-85a4b17cacbc/256.webp" alt="Ngăn xếp Java - 1" loading="lazy" data-max-width="256" data-id="f8e725f0-50c1-4854-a2f0-85a4b17cacbc" data-is-external-image="true">Những gì đang xảy ra ở đây? Chúng tôi có một cái bình trong đó mỗi lần chỉ có thể đánh một quả bóng. Đầu tiên trong bình là một quả bóng màu cam, sau đó là màu tím và cuối cùng là màu xanh lá cây (tôi xin lỗi những ai biết tên chính xác hơn của những màu này). Tuy nhiên, để lấy một quả bóng màu cam từ ngăn xếp bình của chúng ta, trước tiên chúng ta cần lấy quả bóng ở đó cuối cùng (quả màu xanh lá cây), sau đó là quả bóng áp chót (nhưng tại thời điểm lấy nó là quả cuối cùng). một). Cấu trúc dữ liệu ngăn xếp trong Java hay bất kỳ nơi nào khác trong lập trình có hai thao tác quan trọng nhất là <span class="text-bold">đẩy</span> và <span class="text-bold">bật</span> . Thao tác đẩy chèn một phần tử vào ngăn xếp và thao tác pop loại bỏ một phần tử khỏi đỉnh ngăn xếp.</p><h2>Cấu trúc dữ liệu Stack để làm gì?</h2><p>Một trong những ứng dụng quan trọng nhất của ngăn xếp là tổ chức các cuộc gọi chương trình con. Điểm gọi trên ngăn xếp lưu trữ địa chỉ trả về từ chương trình con sau khi nó kết thúc (và có thể cả các tham số được truyền vào). Với mỗi lệnh gọi lồng nhau (bao gồm cả đệ quy) của các chương trình con, các địa chỉ trả về mới được thêm vào ngăn xếp. Với mỗi thao tác trả về từ chương trình con (trả về), địa chỉ trả về sẽ bị xóa khỏi ngăn xếp và quyền điều khiển được chuyển đến nó. Ứng dụng này quan trọng đối với lập trình đến nỗi trong hầu hết các bộ xử lý, ngăn xếp trả về được triển khai trong phần cứng trong tập lệnh. Tuy nhiên, trong các trường hợp khác, ngăn xếp phải được mô hình hóa trên các cấu trúc dữ liệu tổng quát hơn.</p><h2>Lớp khung công tác bộ sưu tập Java Stack</h2><p>Trong Java Lớp <span class="code">ngăn xếp</span> là một lớp từ khung Bộ sưu tập thực hiện giao diện Danh sách và mở rộng lớp Vector. Nó cũng triển khai các giao diện Collection, Iterable, Cloneable, Serializable. Như bạn có thể đã đoán, lớp này đại diện cho chồng đối tượng LIFO. Đây là lệnh gọi hàm tạo của lớp <span class="code">Stack</span> , nghĩa là tạo một đối tượng của lớp này.</p><pre class="line-numbers language-java" tabindex="0"><code>Stack&lt;E&gt; stack = new Stack&lt;E&gt;();</code></pre><p>Trong đó <span class="code">E</span> là loại Đối tượng.</p><h2>Phương pháp ngăn xếp Java</h2><p>Lớp này chỉ có một hàm tạo mặc định và tất cả các phương thức của lớp <span class="code">Vector</span> . Ngoài ra, <span class="code">Stack</span> có 5 phương thức riêng:</p><ul><li><p><span class="code">boolean empty()</span> phương thức kiểm tra xem ngăn xếp có rỗng hay không. Trả về <em>true</em> nếu ngăn xếp trống, <em>false</em> nếu không.</p></li><li><p><span class="code">Đối tượng peek()</span> phương thức trả về phần tử ở trên cùng của ngăn xếp.</p></li><li><p><span class="code">Object pop()</span> phương thức trả về phần tử ở trên cùng của ngăn xếp và loại bỏ nó.</p></li><li><p><span class="code">Đẩy đối tượng(Phần tử đối tượng)</span> phương thức thêm phần tử đã chỉ định vào đầu ngăn xếp.</p></li><li><p><span class="code">int search(Object element)</span> phương thức tìm kiếm ngăn xếp cho phần tử đã chỉ định. Nếu phần tử được yêu cầu được tìm thấy, thì "khoảng cách" của nó từ trên cùng (số sê-ri) sẽ được trả về. Nếu phần tử không được tìm thấy, -1 được trả về.</p></li></ul><h2>Ví dụ mã ngăn xếp</h2><p>Hãy tạo một ví dụ chương trình hoạt động như ảnh gif ở trên. Chúng tôi sẽ đặt ba "quả bóng", cam, tím và xanh lá cây, trên ngăn xếp. Hãy kiểm tra ngăn xếp xem có trống không. Sau đó, chúng tôi sẽ lấy các quả bóng từ ngăn xếp cho đến khi ngăn xếp trống.</p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Stack;

public class myStackTest2 {

       public static void main(String[] args)
       {

           Stack myStack= new Stack&lt;&gt;();

           System.out.println("Is my stack empty? " + myStack.empty());

           myStack.push("Orange Ball");
           myStack.push("Violet Ball");
           myStack.push("Green Ball");


           System.out.println("Elements in Stack: " + myStack);
           System.out.println("Is my stack empty? " + myStack.empty());
           while (!myStack.isEmpty()) {
               myStack.pop();
               System.out.println("Elements in Stack: " + myStack);
               System.out.println("Is my stack empty? " + myStack.empty());
           }
       }
   }</code></pre><p>Đây là đầu ra của chương trình này:</p><div class="terminal">Ngăn xếp của tôi có trống không? ĐÚNG VẬY Các thành phần trong ngăn xếp: [Quả bóng màu cam, Quả bóng màu tím, Quả bóng màu xanh lá cây] Ngăn xếp của tôi có trống không? SAI Các thành phần trong ngăn xếp: [Quả bóng màu cam, Quả bóng màu tím] Ngăn xếp của tôi có trống không? SAI Các phần tử trong ngăn xếp: [Quả bóng màu cam] Ngăn xếp của tôi có trống không? SAI Các phần tử trong ngăn xếp: [] Ngăn xếp của tôi có trống không? ĐÚNG VẬY</div><p>Do <span class="code">Stack</span> được kế thừa từ Lớp <span class="code">Vector</span> và triển khai giao diện <span class="code">Danh sách</span> , nên ngoài các thao tác đẩy và bật cổ điển cho cấu trúc dữ liệu này để thêm và trích xuất các phần tử, <span class="code">Stack còn có tiêu chuẩn cho các thao tác </span><span class="code">thêm ()</span> và <span class="code">xóa ()</span> của cấu trúc danh sách . Trong ví dụ của chúng tôi, việc thêm các phần tử có thể được thực hiện theo cách tương tự bằng cách sử dụng phương thức <span class="code">add()</span> . Tuy nhiên, bạn chỉ có thể trích xuất bằng cách sử dụng <span class="code">remove() với một phần tử được chỉ định, điều này không có ý nghĩa gì đối với cấu trúc dữ liệu ngăn xếp.</span></p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Stack;

public class myStackTest2 {

       public static void main(String[] args)
       {

           Stack myStack= new Stack&lt;&gt;();

           System.out.println("Is my stack empty? " + myStack.empty());

           myStack.add("Orange Ball");
           myStack.add("Violet Ball");
           myStack.add("Green Ball");


           System.out.println("Elements in Stack: " + myStack);
           System.out.println("Is my stack empty? " + myStack.empty());
           while (!myStack.isEmpty()) {
               myStack.pop();
               System.out.println("Elements in Stack: " + myStack);
               System.out.println("Is my stack empty? " + myStack.empty());
           }
       }
   }</code></pre><p>Tất nhiên, kết quả của công việc chương trình sẽ giống hệt nhau.</p><h2>Còn việc triển khai Stack của riêng bạn thì sao?</h2><p>Bạn có thể tạo cấu trúc dữ liệu ngăn xếp của riêng mình trong Java bằng cách sử dụng mảng hoặc lớp danh sách liên kết. Trong trường hợp đầu tiên, một mảng ô liên tục được phân bổ để lưu trữ các giá trị trong bộ nhớ, được sử dụng khi cần thiết. Trong trường hợp thứ hai, đối với mỗi phần tử của ngăn xếp, một khối bộ nhớ được sắp xếp, đủ để lưu trữ giá trị và tham chiếu đến các phần tử trước đó và tiếp theo của ngăn xếp. Việc triển khai dựa trên mảng đơn giản hơn, hiệu quả hơn và tiết kiệm bộ nhớ hơn, nhưng nó yêu cầu kiến ​​thức trước về giới hạn kích thước ngăn xếp và có thể dẫn đến các lỗi khó tìm. Việc triển khai dựa trên danh sách mạnh mẽ hơn nhưng kém hiệu quả hơn. Hãy thực hiện một triển khai ngăn xếp dựa trên mảng đơn giản. Nó sẽ bao gồm các chức năng.</p><ul><li><p><span class="code">đẩy</span> - một phương thức sẽ đảm bảo thêm một phần tử (ở vị trí trên cùng)</p></li><li><p><span class="code">pop</span> — một phương thức sẽ cung cấp việc loại bỏ một phần tử (từ vị trí trên cùng)</p></li><li><p><span class="code">readTop</span> — một phương thức sẽ trả về giá trị của phần tử ở vị trí trên cùng</p></li><li><p><span class="code">sEmpty</span> — một phương thức sẽ kiểm tra sự trống rỗng của ngăn xếp</p></li><li><p><span class="code">isFull</span> — một phương thức sẽ kiểm tra xem mảng mà chúng ta lưu trữ ngăn xếp có đầy không</p></li></ul><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Arrays;

public class MyStack {

   private int maxSize;
   private String[] stackArray;
   private int top;

   public MyStack(int size) {
       this.maxSize = size;
       stackArray = new String[maxSize];
       top = -1;
   }

   public String push (String element) {
       return stackArray[++top] = element;

   }

   public String pop (String element) {

       if (isEmpty())
       {
           System.out.println("Underflow\nProgram Terminated");
           System.exit(-1);
       }

       System.out.println("Removing " + readTop());

       return stackArray[top--];

   }

   public String readTop() {
       return stackArray[top];

   }

   public boolean isEmpty() {
       return (top ==  -1);
   }

   public boolean isFull() {
       return (top == maxSize - 1);
   }

   public void printStack(){
       System.out.println(Arrays.toString(stackArray));
   }
}</code></pre><p>Bây giờ, hãy thực hiện một ví dụ với ba quả bóng dựa trên ngăn xếp của chúng tôi:</p><pre class="line-numbers language-java" tabindex="0"><code>public class myStackTest {
   public static void main(String[] args) {
       MyStack  myStack = new MyStack(3);
       System.out.println("Is my stack empty? " + myStack.isEmpty());

       myStack.push("Orange Ball");
       myStack.push("Violet Ball");
       myStack.push("Green Ball");

      myStack.printStack();

       System.out.println("Is my stack empty? " + myStack.isEmpty());
       while (!myStack.isEmpty()) {
           myStack.pop(myStack.readTop());
           System.out.println("Is my stack empty? " + myStack.isEmpty());
       }
   }

}</code></pre><p>Đầu ra ở đây:</p><div class="terminal">Ngăn xếp của tôi có trống không? ĐÚNG VẬY [Bóng cam, Bóng tím, Bóng xanh] Ngăn xếp của tôi có trống không? SAI Loại bỏ bóng xanh Ngăn xếp của tôi có trống không? SAI Loại bỏ bóng tím Ngăn xếp của tôi có trống không? SAI Loại bỏ quả bóng màu cam Ngăn xếp của tôi có trống không? ĐÚNG VẬY</div><p>Nếu bạn nhìn kỹ, biến trên cùng thực sự chứa chỉ mục của phần tử cuối cùng và tham chiếu đến đối tượng vẫn còn trong mảng. Vì vậy, việc thực hiện này cần một số cải tiến. Hãy suy nghĩ về cách dễ nhất để làm điều này.</p><h2>Chúng ta có nên sử dụng Java Stack không?</h2><p>Trên thực tế, Java<span class="code"> Stack</span> , giống như <span class="code">Vector</span> cha của nó, là một lớp kế thừa. Thay vào đó, lớp <span class="code">ArrayList</span> thường được sử dụng. <span class="code">ArrayList</span> không được đồng bộ hóa trong khi <span class="code">Vector</span> được đồng bộ hóa. Điều đó có nghĩa là với <span class="code">Vector,</span> chỉ một luồng tại một thời điểm có thể truy cập mã, trong khi <span class="code">ArrayList</span> có thể hoạt động với nhiều luồng. Ngoài ra, <span class="code">ArrayList</span> hiệu quả hơn và nhanh hơn. Vì vậy, rất có thể bạn sẽ chỉ thấy lớp này trong mã kế thừa. Nhưng cấu trúc dữ liệu <span class="code">Stack</span> được sử dụng rất thường xuyên trong lập trình.</p></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on December 31, 2024</p><div class="post__share-tag-container"><div class="post__tag"><h3>Tagged in:</h3><ul><li><a href="https://nguyenkhai03.github.io/gh-pages/tags/blog/">BLOG</a></li></ul></div><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"></div></div></div><div class="post__bio"><img src="https://nguyenkhai03.github.io/gh-pages/media/website/351272991_979314233203495_2887816723783302460_n.jpg" loading="lazy" height="206" width="218" alt="Nguyễn Đăng Khải"><div><h3><a href="https://nguyenkhai03.github.io/gh-pages/authors/nguyen-dang-khai/" class="invert" rel="author">Nguyễn Đăng Khải</a></h3></div></div></footer></article><div><strong>You should also read:</strong></div><div class="posts"><article><header><time datetime="2024-12-31T23:59" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html">Các Công Cụ Tối Ưu Hóa JavaScript</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/12/1706322865-yRkGgMr.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="500" width="800" alt=""></a><p>Nếu bạn đang băn khoăn tìm kiếm cho mình một thư viện JavaScript hay ho thì bạn đã ghé đúng nơi rồi. Ở&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:59" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html">Vòng lặp Java While</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/9/hqdefault.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="360" width="480" alt="Vòng lặp Java While"></a><p>Vòng lặp while được tìm thấy trong hầu hết mọi ngôn ngữ lập trình và Java cũng không ngoại lệ. Vòng lặp While&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:57" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html">Danh sách Java</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/7/list-java.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="480" width="900" alt=""></a><p>Java Collection Framework chứa các giao diện và lớp rất hữu ích triển khai chúng để làm việc với các cấu trúc dữ&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:56" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html">Lớp Java.util.Random</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/6/Random-trong-java-la-gi-3.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="383" width="679" alt=""></a><p>Lớp java.util.Random trong Java là gì? Lớp java.util.Random được sử dụng để tạo các số giả ngẫu nhiên. Các phương thức do lớp&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html" class="button">Full Story</a></li></ul></article></div></main><footer id="copyright"><ul><li>© Massively</li><li>Design: <a href="https://html5up.net" target="_blank" rel="nofollow noopener">HTML5 UP</a></li><li>Powered by Publii</li></ul></footer></div><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.min.js?v=c9771cc3e90e18f5336eedbd0fffb2cf"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/main.min.js?v=56233c354bd814758be8bff42f7e13a5"></script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>