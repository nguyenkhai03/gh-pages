<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Bộ Java - Profile</title><meta name="description" content="Set là một giao diện trong Java Collection Framework. Bạn có thể sử dụng Java Set để triển khai các bộ sưu tập&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://nguyenkhai03.github.io/gh-pages/bo-java.html"><link rel="alternate" type="application/atom+xml" href="https://nguyenkhai03.github.io/gh-pages/feed.xml"><link rel="alternate" type="application/json" href="https://nguyenkhai03.github.io/gh-pages/feed.json"><meta property="og:title" content="Bộ Java"><meta property="og:image" content="https://nguyenkhai03.github.io/gh-pages/media/posts/4/2024_5_26_638523318583850865_anh-dai-dien.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1280"><meta property="og:site_name" content="Profile"><meta property="og:description" content="Set là một giao diện trong Java Collection Framework. Bạn có thể sử dụng Java Set để triển khai các bộ sưu tập&hellip;"><meta property="og:url" content="https://nguyenkhai03.github.io/gh-pages/bo-java.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/fontawesome-all.min.css?v=85514f933f9e0b82460af63f1a403fa5"><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/style.css?v=a43d11e6c8e1828dd0b983b73b3cdb13"><noscript><link rel="stylesheet" href="https://nguyenkhai03.github.io/gh-pages/assets/css/noscript.css?v=efa867a99f5064d6729e4dc2008ad50b"></noscript><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://nguyenkhai03.github.io/gh-pages/bo-java.html"},"headline":"Bộ Java","datePublished":"2024-12-31T20:55+07:00","dateModified":"2024-12-31T23:31+07:00","image":{"@type":"ImageObject","url":"https://nguyenkhai03.github.io/gh-pages/media/posts/4/2024_5_26_638523318583850865_anh-dai-dien.jpg","height":1280,"width":1920},"description":"Set là một giao diện trong Java Collection Framework. Bạn có thể sử dụng Java Set để triển khai các bộ sưu tập&hellip;","author":{"@type":"Person","name":"Nguyễn Đăng Khải","url":"https://nguyenkhai03.github.io/gh-pages/authors/nguyen-dang-khai/"},"publisher":{"@type":"Organization","name":"Nguyễn Đăng Khải"}}</script><style>#wrapper > .bg {
               background-image: url(https://nguyenkhai03.github.io/gh-pages/assets/images/overlay.png), linear-gradient(0deg, rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1)), url(https://nguyenkhai03.github.io/gh-pages/media/website/photo-1506126613408-eca07ce68773.avif);
           }</style><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="is-preload post-template"><div id="wrapper"><header id="header"><a class="logo" href="https://nguyenkhai03.github.io/gh-pages/">Profile</a></header><nav id="nav"><ul class="links"><li><a href="https://nguyenkhai03.github.io/gh-pages/" target="_self">HOME</a></li><li><a href="https://nguyenkhai03.github.io/gh-pages/tags/blog/" target="_self">BLOG</a></li><li><a href="https://nguyenkhai03.github.io/gh-pages/profile-ca-nhan.html" target="_self">PROFILE</a></li></ul></nav><main id="main"><article class="post"><header class="major"><time datetime="2024-12-31T20:55" class="date">December 31, 2024</time><h1>Bộ Java</h1><p class="post__inner"></p></header><figure class="image main"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/4/2024_5_26_638523318583850865_anh-dai-dien.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/4/responsive/2024_5_26_638523318583850865_anh-dai-dien-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/4/responsive/2024_5_26_638523318583850865_anh-dai-dien-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/4/responsive/2024_5_26_638523318583850865_anh-dai-dien-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/4/responsive/2024_5_26_638523318583850865_anh-dai-dien-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/4/responsive/2024_5_26_638523318583850865_anh-dai-dien-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="1280" width="1920" alt=""></figure><div class="post__inner post__entry"><p><span class="code">Set</span> là một giao diện trong Java Collection Framework. Bạn có thể sử dụng Java <span class="code">Set</span> để triển khai các bộ sưu tập không có thứ tự với các phần tử duy nhất. Trong bài viết này, chúng ta sẽ xem xét giao diện này và các triển khai của nó trong ngôn ngữ Java, các phương pháp để làm việc với một tập hợp và cũng đưa ra một số ví dụ.</p><h2>Bộ Java là gì</h2><p><span class="code">Set</span> là một giao diện từ Java Collection Framework, nhưng <span class="code">Set</span> không phải là một collection có thứ tự, không giống như <span class="code">List</span> . Điều đó có nghĩa là các phần tử <span class="code">của Tập hợp</span> Java được lưu giữ mà không có một thứ tự cụ thể nào. Vì vậy, không có quyền kiểm soát vị trí mà bạn có thể chèn một phần tử. Ngoài ra, bạn không thể truy cập các phần tử theo chỉ mục của chúng. Về mặt toán học, <span class="code">Tập hợp</span> là một tập hợp các phần tử duy nhất. Trên thực tế, đây là một Bộ sưu tập không có thứ tự (Bộ sưu tập không có thứ tự), trong đó các phần tử giống hệt nhau không thể được lưu trữ. Nếu bạn cố tình thêm một phần tử trùng lặp vào <span class="code">Set</span> , hành động này sẽ bị bỏ qua và <span class="code">Set</span> sẽ không thay đổi. Tuy nhiên, được phép lưu trữ một phần tử null trong đó.</p><h2>Đặt triển khai</h2><p>Java<span class="code"> Set</span> là một giao diện, vì vậy bạn cần sử dụng một trong các triển khai của nó để tạo các đối tượng. Đây là <span class="code">HashSet</span> , <span class="code">TreeSet</span> và <span class="code">LinkedHashSet</span> . Trong <span class="code">Set</span> s, mỗi phần tử chỉ được lưu trữ trong một phiên bản và các cách triển khai khác nhau của Set sử dụng một thứ tự khác nhau để lưu trữ các phần tử. Trong một <span class="code">HashSet</span> , thứ tự của các phần tử được xác định bởi một thuật toán phức tạp. Nếu thứ tự lưu trữ quan trọng đối với bạn, hãy sử dụng bộ chứa <span class="code">TreeSet</span> , nơi lưu trữ các đối tượng được sắp xếp theo thứ tự tăng dần theo thứ tự so sánh hoặc <span class="code">LinkedHashSet</span>, lưu trữ các phần tử theo thứ tự bổ sung. Các tập hợp thường được sử dụng để kiểm tra tư cách thành viên để bạn có thể dễ dàng kiểm tra xem một đối tượng có thuộc một tập hợp nhất định hay không, do đó, trong thực tế, việc triển khai <span class="code">HashSet</span> được tối ưu hóa để tra cứu nhanh thường được chọn. <span class="code">HashSet</span> là một bộ sưu tập sử dụng các giá trị băm của chúng được trả về bởi phương thức <span class="code">hashCode()</span> để lưu trữ các phần tử bên trong. Tức là bên trong <span class="code">HashSet&lt;E&gt;</span> , đối <span class="code">tượng HashMap&lt;E, Object&gt;</span> được lưu trữ, lưu trữ các giá trị của <span class="code">HashSet</span> dưới dạng khóa. Sử dụng mã băm cho phép bạn nhanh chóng tìm kiếm, thêm và xóa các phần tử khỏi <span class="code">Tập hợp</span> . <span class="code">LinkedHashSet</span> là một <span class="code">HashSet</span>cũng lưu trữ các phần tử trong một danh sách được liên kết. Một <span class="code">HashSet</span> bình thường không duy trì thứ tự phần tử. Thứ nhất, về mặt chính thức, nó đơn giản là không tồn tại, và thứ hai, ngay cả thứ tự bên trong cũng có thể thay đổi đáng kể khi chỉ một phần tử được thêm vào. Và bạn có thể lấy một trình vòng lặp từ <span class="code">LinkedHashSet</span> và sử dụng nó để duyệt qua tất cả các phần tử theo đúng thứ tự mà chúng được thêm vào <span class="code">LinkedHashSet</span> . Không thường xuyên, nhưng đôi khi nó có thể rất cần thiết. TreeSet là một bộ sưu tập lưu trữ các phần tử dưới dạng cây có thứ tự giá trị. Bên trong <span class="code">TreeSet&lt;E&gt;</span> là một <span class="code">TreeMap&lt;E, Object&gt;</span> lưu trữ tất cả các giá trị này. Và <span class="code">TreeMap này</span>sử dụng cây nhị phân cân bằng đỏ đen để lưu trữ các phần tử. <span class="code">Do đó, nó có các thao tác add()</span> , <span class="code">remove()</span> , <span class="code">contains()</span> rất nhanh .</p><h2>Tạo đối tượng tập hợp</h2><p>Để tạo Đối tượng <span class="code">Tập hợp</span> , bạn có thể sử dụng một trong các biểu mẫu sau:</p><pre class="line-numbers language-java" tabindex="0"><code>Set&lt;Integer&gt; intSet = new HashSet&lt;&gt;();
Set&lt;String&gt; vSet = new HashSet&lt;&gt;();
Set mySet = new LinkedHashSet();
HashSet&lt;String&gt; myHashset = new HashSet&lt;&gt;();</code></pre><p>Đây là một ví dụ đơn giản, trong đó chúng tôi tạo 2 <span class="code">Set</span> s, <span class="code">HashSet</span> và <span class="code">LinkedHashSet</span> và thêm vào mỗi phần tử 5 phần tử. Chúng ta có thể sử dụng phương thức <span class="code">add()</span> cho việc này.</p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;

public class HashSetTest {
    public static void main(String[] args) {
        Set mySet = new HashSet();
        Set mySet2 = new LinkedHashSet();

        mySet.add("Stuart");
        mySet.add("Alex");
        mySet.add("Johnny");
        mySet.add("Igor");
        mySet.add("Bel");
        System.out.println(mySet);
        mySet2.add("Stuart");
        mySet2.add("Alex");
        mySet2.add("Johnny");
        mySet2.add("Igor");
        mySet2.add("Bel");
        System.out.println(mySet2);
    }
}</code></pre><p>Đây là đầu ra của chương trình:</p><div class="terminal">[Alex, Igor, Stuart, Johnny, Bel] [Stuart, Alex, Johnny, Igor, Bel]</div><p>Như chúng tôi đã đề cập ở trên, <span class="code">HashSet</span> không duy trì thứ tự của các phần tử, nhưng <span class="code">LinkedHashSet</span> thì có. Chính <span class="code">LinkedHashSet</span> đã cung cấp cho chúng tôi các phần tử theo thứ tự mà chúng tôi đã viết chúng vào tập hợp.</p><h2>Các phương thức tập hợp Java</h2><p>Dưới đây là một số phương thức quan trọng của Java <span class="code">Set</span> :</p><ul><li><p><span class="code">boolean thêm(E e)</span> . Thêm phần tử đã chỉ định vào tập hợp nếu nó chưa có (thao tác tùy chọn).</p></li><li><p><span class="code">boolean loại bỏ (Đối tượng o)</span> . Xóa phần tử đã chỉ định khỏi tập hợp này nếu có (thao tác tùy chọn).</p></li><li><p><span class="code">boolean removeAll(Bộ sưu tập c)</span> . Xóa khỏi tập hợp này tất cả các phần tử của nó có trong tập hợp đã chỉ định (thao tác tùy chọn).</p></li><li><p><span class="code">boolean holdAll(Bộ sưu tập c)</span> . Chỉ giữ lại các phần tử trong tập hợp này được chứa trong tập hợp đã chỉ định (thao tác tùy chọn).</p></li><li><p><span class="code">xóa khoảng trống()</span> . Xóa tất cả các phần tử khỏi tập hợp.</p></li><li><p><span class="code">Trình lặp iterator()</span> . Trả về một trình vòng lặp trên các phần tử trong tập hợp này.</p></li><li><p><span class="code">kích thước int()</span> . nó được sử dụng để lấy số phần tử trong Tập hợp.</p></li><li><p><span class="code">boolean isEmpty()</span> . để kiểm tra xem Set có trống hay không.</p></li><li><p><span class="code">boolean chứa(Đối tượng o)</span> . Trả về true nếu Tập hợp này chứa phần tử đã chỉ định.</p></li><li><p><span class="code">Trình lặp iterator()</span> . Trả về một trình vòng lặp trên các phần tử trong tập hợp này. Các phần tử được trả về không theo thứ tự cụ thể.</p></li><li><p><span class="code">Đối tượng[] toArray()</span> . Trả về một mảng chứa tất cả các phần tử trong tập hợp này. Nếu bộ này đưa ra bất kỳ đảm bảo nào về thứ tự các phần tử của nó được trả về bởi trình vòng lặp của nó, thì phương thức này phải trả về các phần tử theo cùng một thứ tự.</p></li></ul><p>Các phương thức này tương tự như các phương thức của <span class="code">ArrayList</span> , ngoại trừ phương thức <span class="code">add(Object o)</span> chỉ thêm một đối tượng vào tập hợp nếu nó chưa có ở đó. Giá trị trả về của phương thức là true nếu đối tượng đã được thêm vào và false nếu không. Ngoài ra còn có một số phương thức kế thừa từ <span class="code">Collection&lt;&gt;</span> Interface: phương <span class="code">thức parallelStream()</span> , <span class="code">removeIf()</span> , <span class="code">stream()</span> và <span class="code">forEach()</span> kế thừa từ <span class="code">java.lang.Iterable</span> Interface.</p><h2>Java Đặt ví dụ hoạt động chính</h2><p>Trong ví dụ này, chúng tôi tạo một mảng các chuỗi và sau đó chuyển nó tới <span class="code">mySet</span> bằng thao tác <span class="code">Arrays.asList</span> . Sau đó, chúng tôi loại bỏ thêm một số yếu tố và thêm một số yếu tố khác. Trong trường hợp này, một trong các thành phần trong tập hợp đã tồn tại: nó sẽ không được thêm vào. Chúng tôi cũng sẽ thử các thao tác kiểm tra sự trống rỗng <span class="code">isEmpty()</span> , xác định kích thước của tập hợp <span class="code">size()</span> và xóa tập hợp tất cả các phần tử <span class="code">clear()</span> .</p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class HashSetTest2 {
   public static void main(String[] args) {
       
       String [] friends =  {"Stuart", "Ivy", "Johnny", "Alex", "Igor", "Tanya"};
       
       Set&lt;String&gt; mySet = new HashSet&lt;&gt;(Arrays.asList(friends));
       System.out.println(mySet);
       
       mySet.remove("Igor");
       mySet.remove("Stuart");

       System.out.println(mySet);

       
       mySet.add("Dasha");
       mySet.add("Alex"); 
       System.out.println(mySet);
       
       int size = mySet.size();
       System.out.println("The quantity of set's elements = " + size);
       
       System.out.println("Is mySet empty? " + mySet.isEmpty());
       
       System.out.println("Is Igor in set? " + mySet.contains("Igor"));
       System.out.println("Is Johnny in set? "+ mySet.contains("Johnny"));
       
       mySet.clear();
       System.out.println("Is mySet empty now? " + mySet.isEmpty());

   }
}</code></pre><p>Đầu ra của chương trình là đây:</p><div class="terminal">[Alex, Igor, Stuart, Tanya, Johnny, Ivy] [Alex, Tanya, Johnny, Ivy] [Alex, Dasha, Tanya, Johnny, Ivy] Số lượng phần tử của tập hợp = 5 MySet có trống không? sai Igor có trong tập hợp không? sai Johnny có ở trong phim trường không? true Bây giờ mySet có trống không? ĐÚNG VẬY</div><h2>Ví dụ với LinkedHashSet và đặt thành Array</h2><p>Hãy viết một chương trình khác. Trong đó, chúng tôi sẽ tạo một tập hợp dựa trên <span class="code">LinkedHashSet</span> , thêm các phần tử vào đó, sau đó chuyển đổi tập hợp thành một mảng.</p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;
   public class LinkedHashSet3 {
       public static void main(String[] args) {
           Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;();
           set.add("C");
           set.add("D");
           set.add("E");
           set.add("F");
           set.add("G");
           set.add("A");
           set.add("B");
           System.out.println(set);
           set.remove("F");
           set.remove("C sharp");
           System.out.println(set.remove("C sharp"));
           System.out.println("Print our set with elements removed: ");
           System.out.println(set);


           String strArray[] = set.toArray(new String[set.size()]);
           System.out.println("New Array from set: ");
           System.out.println(Arrays.toString(strArray));
           System.out.println(strArray[0]);

       }
   }</code></pre><p>Đây là đầu ra của chương trình:</p><div class="terminal">[C, D, E, F, G, A, B] false In tập hợp của chúng ta với các phần tử đã bị xóa: [C, D, E, G, A, B] Mảng mới từ tập hợp: [C, D, E, G, A, B] C</div><h2>Đặt ví dụ với iterator</h2><p>Hãy tạo một tập hợp, sau đó in nó ra bằng một trình vòng lặp, sau đó xóa tất cả các số chẵn khỏi nó, cũng bằng một trình vòng lặp.</p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.*;

public class SetTest5
{
   public static void main(String[] args)
   {

       Set&lt;Integer&gt; mySet = new HashSe&lt;&gt;();
       for(int i = 0; i &lt; 10; i++)
           mySet.add(i);

       Iterator iterator = mySet.iterator();

       
       while(iterator.hasNext()){
           int i = (int) iterator.next();
       }
       System.out.println(" " + mySet);

       
       iterator = mySet.iterator();
       while(iterator.hasNext()){
           int x = (int) iterator.next();
           if(x%2 == 0) iterator.remove();
       }
       System.out.println(mySet);

       }
}</code></pre><p>Đầu ra của chương trình là đây:</p><div class="terminal">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [1, 3, 5, 7, 9</div><h2>Ví dụ với TreeSet</h2><p>Nếu việc sắp xếp là quan trọng đối với bạn, thì hãy sử dụng triển khai <span class="code">TreeSet</span> . Trong ví dụ ngắn này, chúng tôi sẽ điền vào tập hợp tên của những người bạn, như trong các ví dụ trước. Tuy nhiên, trong một <span class="code">TreeSet</span> được sắp xếp , các phần tử sẽ ngay lập tức được viết theo thứ tự đã sắp xếp. Trong trường hợp này, tên sẽ được hiển thị theo thứ tự bảng chữ cái.</p><pre class="line-numbers language-java" tabindex="0"><code>import java.util.Set;
import java.util.TreeSet;
public class TreeSetTest {

   public static void main(String[] args) {

       Set mySet = new TreeSet&lt;&gt;();
       mySet.add("Stuart");
       mySet.add("Alex");
       mySet.add("Johnny");
       mySet.add("Igor");
       mySet.add("Bel");
       System.out.println(mySet);

   }</code></pre><p>Đầu ra là:</p><div class="terminal">[Alex, Bel, Igor, Johnny, Stuart]</div><h2>kết luận ngắn gọn</h2><ul><li><p>Giao diện Java <span class="code">Set</span> là một phần của Java Collections Framework.</p></li><li><p>Các lớp đã triển khai: <span class="code">AbstractSet</span> , <span class="code">ConcurrentHashMap.KeySetView</span> , <span class="code">ConcurrentSkipListSet</span> , <span class="code">CopyOnWriteArraySet</span> , <span class="code">EnumSet</span> , <span class="code">HashSet</span> , <span class="code">JobStateReasons</span> , <span class="code">LinkedHashSet</span> , <span class="code">TreeSet</span> .</p></li><li><p><span class="code">Các triển khai Set</span> phổ biến nhất là <span class="code">HashSet</span> , <span class="code">LinkedHashSet</span> và <span class="code">TreeSet</span> .</p></li><li><p><span class="code">Thứ tự phần tử HashSet</span> được xác định bởi một thuật toán phức tạp. Nếu thứ tự lưu trữ quan trọng đối với bạn, hãy sử dụng vùng chứa <span class="code">TreeSet</span> , nơi lưu trữ các đối tượng được sắp xếp theo thứ tự tăng dần theo thứ tự so sánh hoặc LinkedHashSet <span class="code">,</span> nơi lưu trữ các phần tử theo thứ tự bổ sung.</p></li><li><p>Thông thường, các bộ được sử dụng để kiểm tra tư cách thành viên. Đó là, để kiểm tra xem một đối tượng có thuộc một tập hợp nhất định theo nghĩa toán học hay không. Vì vậy, thông thường nhất trong tất cả các triển khai <span class="code">Set</span> trong thực tế, <span class="code">HashSet</span> thường được chọn. Việc triển khai này được tối ưu hóa để tìm kiếm nhanh.</p></li><li><p>Bạn không thể thêm các phần tử trùng lặp vào một tập hợp, vì vậy, bạn có thể sử dụng các triển khai của giao diện <span class="code">Tập hợp</span> để lưu trữ các phần tử duy nhất.</p></li><li><p><span class="code">Set</span> cho phép bạn chỉ thêm một phần tử null.</p></li><li><p><span class="code">Tập hợp</span> không phải là một danh sách và không hỗ trợ chỉ mục hoặc vị trí của các phần tử trong đó.</p></li></ul></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on December 31, 2024</p><div class="post__share-tag-container"><div class="post__tag"><h3>Tagged in:</h3><ul><li><a href="https://nguyenkhai03.github.io/gh-pages/tags/blog/">BLOG</a></li></ul></div><div class="post__share"><button class="post__share-button js-post__share-button icon" aria-label="Share button"><i class="fas fa-share-alt"></i></button><div class="post__share-popup js-post__share-popup"></div></div></div><div class="post__bio"><img src="https://nguyenkhai03.github.io/gh-pages/media/website/351272991_979314233203495_2887816723783302460_n.jpg" loading="lazy" height="206" width="218" alt="Nguyễn Đăng Khải"><div><h3><a href="https://nguyenkhai03.github.io/gh-pages/authors/nguyen-dang-khai/" class="invert" rel="author">Nguyễn Đăng Khải</a></h3></div></div></footer></article><div><strong>You should also read:</strong></div><div class="posts"><article><header><time datetime="2024-12-31T23:59" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html">Các Công Cụ Tối Ưu Hóa JavaScript</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/12/1706322865-yRkGgMr.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/12/responsive/1706322865-yRkGgMr-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="500" width="800" alt=""></a><p>Nếu bạn đang băn khoăn tìm kiếm cho mình một thư viện JavaScript hay ho thì bạn đã ghé đúng nơi rồi. Ở&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/phuong-thuc-toan-hoc-java-abs.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:59" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html">Vòng lặp Java While</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/9/hqdefault.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/9/responsive/hqdefault-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="360" width="480" alt="Vòng lặp Java While"></a><p>Vòng lặp while được tìm thấy trong hầu hết mọi ngôn ngữ lập trình và Java cũng không ngoại lệ. Vòng lặp While&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/vong-lap-java-while.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:57" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html">Danh sách Java</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/7/list-java.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/7/responsive/list-java-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="480" width="900" alt=""></a><p>Java Collection Framework chứa các giao diện và lớp rất hữu ích triển khai chúng để làm việc với các cấu trúc dữ&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/danh-sach-java.html" class="button">Full Story</a></li></ul></article><article><header><time datetime="2024-12-31T20:56" class="date">December 31, 2024</time><h2><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html">Lớp Java.util.Random</a></h2></header><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html" class="image fit"><img src="https://nguyenkhai03.github.io/gh-pages/media/posts/6/Random-trong-java-la-gi-3.jpg" srcset="https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-xs.jpg 300w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-sm.jpg 480w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-md.jpg 768w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-lg.jpg 1024w, https://nguyenkhai03.github.io/gh-pages/media/posts/6/responsive/Random-trong-java-la-gi-3-xl.jpg 1360w" sizes="(max-width: 1360px) 100vw, 1360px" loading="lazy" height="383" width="679" alt=""></a><p>Lớp java.util.Random trong Java là gì? Lớp java.util.Random được sử dụng để tạo các số giả ngẫu nhiên. Các phương thức do lớp&hellip;</p><ul class="actions special"><li><a href="https://nguyenkhai03.github.io/gh-pages/lop-javautilrandom.html" class="button">Full Story</a></li></ul></article></div></main><footer id="copyright"><ul><li>© Massively</li><li>Design: <a href="https://html5up.net" target="_blank" rel="nofollow noopener">HTML5 UP</a></li><li>Powered by Publii</li></ul></footer></div><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.min.js?v=c9771cc3e90e18f5336eedbd0fffb2cf"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.scrollex.min.js?v=f89065e3d988006af9791b44561d7c90"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/jquery.scrolly.min.js?v=1ed5a78bde1476875a40f6b9ff44fc14"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/util.min.js?v=4201a626f8c9b614a663b3a1d7d82615"></script><script src="https://nguyenkhai03.github.io/gh-pages/assets/js/main.min.js?v=56233c354bd814758be8bff42f7e13a5"></script><script>/*<![CDATA[*/var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};/*]]>*/</script></body></html>